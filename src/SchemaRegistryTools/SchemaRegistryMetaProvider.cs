using Avro;
using Confluent.SchemaRegistry;
using Kafka.Ksql.Linq.Core.Models;
using Kafka.Ksql.Linq.Core.Abstractions;
using Kafka.Ksql.Linq.Core.Extensions;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Kafka.Ksql.Linq.SchemaRegistryTools;

/// <summary>
/// Utility methods to fetch Avro schemas from Schema Registry and
/// convert them into PropertyMeta arrays for Mapping registration.
/// </summary>
public static class SchemaRegistryMetaProvider
{
    /// <summary>
    /// Fetch key and value schemas for the given entity type and
    /// generate corresponding PropertyMeta definitions.
    /// </summary>
    /// <param name="model">Entity model registered in Kafka.</param>
    /// <param name="client">Schema Registry client.</param>
    /// <returns>Tuple of key and value PropertyMeta arrays.</returns>
    public static (PropertyMeta[] KeyProperties, PropertyMeta[] ValueProperties) GetMetaFromSchemaRegistry(
        EntityModel model,
        ISchemaRegistryClient client)
    {
        if (model == null) throw new ArgumentNullException(nameof(model));
        if (client == null) throw new ArgumentNullException(nameof(client));

        var topicName = model.GetTopicName();

        var keySubject = $"{topicName}-key";
        var valueSubject = $"{topicName}-value";

        PropertyMeta[] keyMeta;
        try
        {
            var keySchema = client.GetLatestSchemaAsync(keySubject).GetAwaiter().GetResult().SchemaString;
            keyMeta = ParseSchema(keySchema);
        }
        catch (SchemaRegistryException e) when (e.ErrorCode == 40401)
        {
            keyMeta = Array.Empty<PropertyMeta>();
        }

        var valueSchema = client.GetLatestSchemaAsync(valueSubject).GetAwaiter().GetResult().SchemaString;
        var valueMeta = ParseSchema(valueSchema);
        return (keyMeta, valueMeta);
    }

    private static PropertyMeta[] ParseSchema(string avroSchema)
    {
        var schema = Avro.Schema.Parse(avroSchema) as RecordSchema
            ?? throw new InvalidOperationException("Expected record schema");

        var metas = new List<PropertyMeta>();
        foreach (var field in schema.Fields)
        {
            var clrType = AvroTypeToClrType(field.Schema, out var precision, out var scale);
            metas.Add(new PropertyMeta
            {
                Name = field.Name,
                PropertyType = clrType,
                IsNullable = field.Schema is UnionSchema u && u.Schemas.Any(s => s.Tag == Avro.Schema.Type.Null),
                Precision = precision,
                Scale = scale,
                Format = null,
                Attributes = Array.Empty<Attribute>(),
                PropertyInfo = null,
                IsAutoGenerated = false
            });
        }
        return metas.ToArray();
    }

    private static Type AvroTypeToClrType(Avro.Schema schema, out int? precision, out int? scale)
    {
        precision = null;
        scale = null;

        if (schema is UnionSchema union)
        {
            foreach (var inner in union.Schemas)
            {
                if (inner.Tag != Avro.Schema.Type.Null)
                    return AvroTypeToClrType(inner, out precision, out scale);
            }
            return typeof(string);
        }

        if (schema is LogicalSchema logical)
        {
            switch (logical.LogicalTypeName)
            {
                case "decimal":
                    if (int.TryParse(logical.GetProperty("precision"), out var p))
                        precision = p;
                    if (int.TryParse(logical.GetProperty("scale"), out var s))
                        scale = s;
                    return typeof(decimal);
                case "timestamp-millis":
                    return typeof(DateTimeOffset);
            }

            schema = logical.BaseSchema;
        }

        return schema.Tag switch
        {
            Avro.Schema.Type.String => typeof(string),
            Avro.Schema.Type.Int => typeof(int),
            Avro.Schema.Type.Long => typeof(long),
            Avro.Schema.Type.Boolean => typeof(bool),
            Avro.Schema.Type.Bytes => typeof(byte[]),
            Avro.Schema.Type.Float => typeof(float),
            Avro.Schema.Type.Double => typeof(double),
            _ => typeof(string)
        };
    }
}
